<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>BYOT!</title>
    <style>
        .warning {
            color: red;
            font-weight: bold;
        }
    </style>
</head>
<body>
<h1>Build your own treap!</h1>

<!-- Instructions -->
<div>
    Usage: click on stuff u want, don't click on stuff you don't want. <br>
    You can right click a disabled checkbox/dropdown to enable all its prerequisites. <br>
    Very high chance of bugs so pls tell if you find any (no refunds for potential lost codeforces rating). <br>
</div>
<hr>

<!-- Shameless promotion -->
<div>
    <label><input type="checkbox" id="signature" checked> Show site tag</label><br>
</div>
<hr>

<!-- Namespace and typedef options -->
<div>
    <label><input type="checkbox" id="use_namespace_std" checked> Use namespace std</label><br>
    <label><input type="checkbox" id="use_ll_typedef" checked> Use ll = long long</label><br>
</div>
<hr>

<!-- Tab character selection -->
<div>
    <label for="tab_char">Choose tab character:</label>
    <select id="tab_char">
        <option value="2spaces">2 spaces</option>
        <option value="3spaces">3 spaces</option>
        <option value="4spaces" selected>4 spaces</option>
        <option value="tab">Tab</option>
    </select>
</div>
<hr>

<!-- Range type -->
<div>
    <label for="range_type">Choose range type:</label>
    <select id="range_type">
        <option value="inc exc" selected>inc exc</option>
        <option value="inc inc">inc inc</option>
    </select>
</div>
<hr>

<!-- Merge option -->
<div>
    <label><input type="checkbox" id="merge_option"> Enable merge</label><br>
</div>
<hr>

<!-- Key type selection (none, int, long long) -->
<div>
    <label for="key_type">Choose key type:</label>
    <select id="key_type">
        <option value="none">None</option>
        <option value="int">int</option>
        <option value="long long">long long</option>
    </select>
    <br>
    <label><input type="checkbox" id="split_option"> Enable split</label><br>
</div>
<hr>

<!-- Size option -->
<div>
    <label><input type="checkbox" id="size_option"> Enable size</label><br>
    <label><input type="checkbox" id="spliti_option"> Enable split by index</label><br>
</div>
<hr>

<!-- Dropdown for value type -->
<div>
    <label for="val_type">Choose value type:</label>
    <select id="val_type">
        <option value="none">None</option>
        <option value="int">int</option>
        <option value="long long">long long</option>
    </select>
</div>
<hr>

<!-- Range aggregates -->
<div>
    <label><input type="checkbox" id="range_agg"> Enable range aggregates</label><br>
    <label><input type="checkbox" id="range_sum"> Enable range sum</label><br>
    <label><input type="checkbox" id="range_max"> Enable range max</label><br>
    <label><input type="checkbox" id="range_min"> Enable range min</label><br>
</div>
<hr>

<!-- Lazy propagation -->
<div>
    <label><input type="checkbox" id="lazy_prop"> Enable lazy propagation</label><br>
    <label><input type="checkbox" id="range_add"> Enable range add</label><br>
    <label><input type="checkbox" id="range_set"> Enable range set</label><br>
</div>
<hr>

<!-- Range updates -->
<div>
    <label><input type="checkbox" id="range_update_key"> Enable range updates (key)</label><br>
    <label><input type="checkbox" id="range_update_index"> Enable range updates (index)</label><br>
</div>
<hr>

<!-- Range queries -->
<div>
    <label><input type="checkbox" id="range_query_key"> Enable range queries (key)</label><br>
    <label><input type="checkbox" id="range_query_index"> Enable range queries (index)</label><br>
</div>
<hr>

<!-- Warning area -->
<div id="warnings" class="warning"></div>
<hr>

<!-- Copy button -->
<button onclick="copyCode()">Copy Code</button>
<div id="copy_status"></div>

<!-- Area to display the code -->
<pre id="code_display"></pre>

<script>
    let warnings = []
    let use_namespace_std = false;
    let use_ll_typedef = false;
    let merge_option = false;
    let key_type = 'none';
    let split_option = false;
    let size_option = false;
    let spliti_option = false;
    let range_sum = false;
    let range_max = false;
    let range_min = false;
    let lazy_prop = false;
    let range_add = false;
    let range_set = false;
    let range_update_key = false;
    let range_update_index = false;
    let range_query_key = false;
    let range_query_index = false;
    let val_type = 'none';
    let range_type = 'inc exc'
    let range_agg = false;
    let signature = true;


    // Static dependencies graph
    const dependencyPairs = [
        ["split_option", "key_type"],
        ["spliti_option", "size_option"],
        ["range_add", "lazy_prop"],
        ["range_set", "lazy_prop"],
        ["range_update_key", "lazy_prop"],
        ["range_update_key", "merge_option"],
        ["range_update_key", "key_type"],
        ["range_update_key", "split_option"],
        ["range_update_index", "lazy_prop"],
        ["range_update_index", "merge_option"],
        ["range_update_index", "size_option"],
        ["range_update_index", "spliti_option"],
        ["range_sum", "size_option"],
        ["range_query_key", "lazy_prop"],
        ["range_query_key", "merge_option"],
        ["range_query_key", "key_type"],
        ["range_query_key", "split_option"],
        ["range_query_index", "lazy_prop"],
        ["range_query_index", "merge_option"],
        ["range_query_index", "size_option"],
        ["range_query_index", "spliti_option"],
        ["range_agg", "val_type"],
        ["range_sum", "range_agg"],
        ["range_max", "range_agg"],
        ["range_min", "range_agg"]
    ];

    const sortedDependencies = topsort(dependencyPairs);

    document.addEventListener("DOMContentLoaded", () => {
        initializeForm();
        handleUpdate();
    });

    function initializeForm() {
        document.querySelectorAll("input[type='checkbox'], select").forEach(el => {
            el.addEventListener("change", handleUpdate);
            el.addEventListener("contextmenu", (e) => {
                e.preventDefault();
                enableDependencies(el.id);
            });
        });
    }

    function isEnabled(id) {
        const element = document.getElementById(id);
        if (element.tagName === "SELECT") {
            return element.value !== element.options[0].value; // not the first/default option
        }
        return element.checked;
    }

    function applyDependencies() {
        sortedDependencies.forEach(id => {
            const dependencies = dependencyPairs
                .filter(pair => pair[0] === id)
                .map(pair => pair[1]);

            const allSatisfied = dependencies.every(depId => isEnabled(depId));
            const element = document.getElementById(id);

            if (element.tagName === "INPUT" && element.type === "checkbox") {
                element.disabled = !allSatisfied;
                if (!allSatisfied) element.checked = false;
            }

            if (element.tagName === "SELECT") {
                element.disabled = !allSatisfied;
                if (!allSatisfied) {
                    element.value = element.options[0].value; // Reset to first option
                }
            }
        });
    }

    function enableDependencies(id) {
        const element = document.getElementById(id);

        // Enable dependencies recursively
        const requiredDeps = dependencyPairs.filter(pair => pair[0] === id).map(pair => pair[1]);

        requiredDeps.forEach(depId => {
            const depElement = document.getElementById(depId);

            // Recursively enable the dependencies of this dependency
            enableDependencies(depId);

            if (depElement.tagName === "INPUT" && depElement.type === "checkbox" && !depElement.checked) {
                depElement.checked = true;
            }

            if (depElement.tagName === "SELECT" && depElement.value === depElement.options[0].value) {
                depElement.value = depElement.options[1].value; // Select second option
            }

            depElement.disabled = false;
        });

        // Now enable the element itself
        if (element.tagName === "SELECT") {
            element.value = element.options[1].value; // Select second option for dropdown
        } else if (element.type === "checkbox") {
            element.checked = true; // Enable checkbox
        }

        element.disabled = false; // Ensure it's not disabled

        handleUpdate(); // Update the state of the page
    }


    function topsort(pairs) {
        let graph = {};
        let deg = {};

        pairs.forEach(([a, b]) => {
            if (!graph[b]) graph[b] = [];
            if (!deg[a]) deg[a] = 0;
            if (!deg[b]) deg[b] = 0;

            graph[b].push(a);
            deg[a]++;
        });

        let sorted = [];
        let queue = Object.keys(deg).filter(k => deg[k] === 0);

        while (queue.length) {
            let current = queue.shift();
            sorted.push(current);

            (graph[current] || []).forEach(neighbor => {
                deg[neighbor]--;
                if (deg[neighbor] === 0) {
                    queue.push(neighbor);
                }
            });
        }

        if (sorted.length !== Object.keys(deg).length) {
            throw new Error("Cycle detected in dependency graph!");
        }

        return sorted;
    }

    function handleUpdate() {
        use_namespace_std = document.getElementById("use_namespace_std").checked;
        use_ll_typedef = document.getElementById("use_ll_typedef").checked;
        merge_option = document.getElementById("merge_option").checked;
        key_type = document.getElementById("key_type").value;
        split_option = document.getElementById("split_option").checked;
        size_option = document.getElementById("size_option").checked;
        spliti_option = document.getElementById("spliti_option").checked;
        range_sum = document.getElementById("range_sum").checked;
        range_max = document.getElementById("range_max").checked;
        range_min = document.getElementById("range_min").checked;
        lazy_prop = document.getElementById("lazy_prop").checked;
        range_add = document.getElementById("range_add").checked;
        range_set = document.getElementById("range_set").checked;
        range_update_key = document.getElementById("range_update_key").checked;
        range_update_index = document.getElementById("range_update_index").checked;
        range_query_key = document.getElementById("range_query_key").checked;
        range_query_index = document.getElementById("range_query_index").checked;
        val_type = document.getElementById("val_type").value;
        range_type = document.getElementById("range_type").value;
        range_agg = document.getElementById("range_agg").checked
        signature = document.getElementById("signature").checked

        clearWarnings();
        applyDependencies();
        checkForWarnings();
        displayWarnings();
        updateCodeDisplay();
    }

    function addWarning(message) {
        warnings.push(message);
    }

    function clearWarnings() {
        warnings = [];
        document.getElementById("warnings").innerHTML = "";
    }

    function checkForWarnings() {
        if (range_update_key || range_update_index || range_query_key || range_update_index) {
            addWarning("The implementation of range operations has quite a high constant factor. Beware of TLE on tight time limits.")
        }
        if (range_sum && val_type !== 'long long') {
            addWarning("Be careful for overflows when using range sum with integers.")
        }
    }

    function displayWarnings() {
        const warningDiv = document.getElementById("warnings");
        if (warnings.length > 0) {
            warningDiv.innerHTML = warnings.join("<br>");
        }
    }

    function copyCode() {
        code = "";
        if (signature) code += "// generated at caterpillow.github.io/byot\n\n";
        code += document.getElementById("code_display").textContent;

        navigator.clipboard.writeText(code).then(() => {
            displayCopyStatus("Code copied successfully!", "success");
        }).catch(err => {
            displayCopyStatus("Failed to copy code!", "error");
        });
    }

    function displayCopyStatus(message, status) {
        const copyStatus = document.getElementById("copy_status");
        copyStatus.textContent = message;
        copyStatus.style.color = status === "success" ? "green" : "red";
        copyStatus.style.fontWeight = "bold";

        setTimeout(() => {
            copyStatus.textContent = "";
        }, 3000);
    }

    function getTabCharacter() {
        const tabChar = document.getElementById('tab_char').value;
        switch (tabChar) {
            case '2spaces':
                return '  '; // 2 spaces
            case '3spaces':
                return '   '; // 3 spaces
            case '4spaces':
                return '    '; // 4 spaces
            case 'tab':
                return '\t'; // Tab character
            default:
                return '    '; // Default is 4 spaces
        }
    }

    function updateCodeDisplay() {
        let code = "";

        let inf = (val_type === 'int' ? '1\'000\'000\'000' : '1\'000\'000\'000\'000\'000\'000')
        let enable_par = false;
        let enable_value = val_type !== 'none'
        let pull = size_option || range_sum || range_max || range_min;
        let push = lazy_prop;

        // start code displaying

        if (lazy_prop) {
            code += `struct Lazy {\n`;
            if (range_add || range_set) code += `    ${val_type} val;\n`;
            if (range_set) code += "    bool inc;\n";
            code += "\n";
            code += `    void operator+=(const Lazy& oth) {\n`;
            if (range_add || range_set) {
                if (range_set) code += "        if (!oth.inc) val = 0, inc = 0;\n";
                code += "        val += oth.val;\n";
            }
            code += "    }\n";
            code += "};\n\n";

            let lazy_id = [];
            if (range_add || range_set) lazy_id.push("0");
            if (range_set) lazy_id.push("true");
            code += `const Lazy lid = {${lazy_id.join(", ")}};\n\n`;
        }

        if (enable_value) {
            code += `struct Value {\n`;
            if (range_sum) code += `    ${val_type} sum;\n`;
            if (range_max) code += `    ${val_type} mx;\n`;
            if (range_min) code += `    ${val_type} mn;\n`;
            code += "\n";
            if (lazy_prop) {
                code += '    void upd(Lazy lazy, int sz) {\n'
                if (range_set) {
                    items = []
                    if (range_sum) items.push("sum = ")
                    if (range_max) items.push("mx = ")
                    if (range_min) items.push("mn = ")
                    if (items.length > 0) code += `        if (!lazy.inc) ${items.join('')}0;\n`
                }
                if (range_add || range_set) {
                    if (range_sum) code += '        sum += lazy.val * sz;\n'
                    if (range_max) code += '        mx += lazy.val;\n'
                    if (range_min) code += '        mn += lazy.val;\n'
                }
                code += '    }\n'
                code += "\n";
            }
            code += `    Value operator+(const Value& oth) const {\n` +
                "        Value res {};\n";
            if (range_sum) code += "        res.sum = sum + oth.sum;\n";
            if (range_max) code += "        res.mx = max(mx, oth.mx);\n";
            if (range_min) code += "        res.mn = min(mn, oth.mn);\n";
            code += "        return res;\n" +
                "    }\n" +
                "};\n\n";

            code += '\n';

            let val_id = [];
            if (range_sum) val_id.push("0")
            if (range_max) val_id.push(`-${inf}`)
            if (range_min) val_id.push(`${inf}`)
            code += `const Value vid = {${val_id.join(", ")}};\n\n`;
        }

        code += "std::mt19937 mt(std::chrono::steady_clock::now().time_since_epoch().count());\n" +
            "using ptr = struct Node*;\n\n" +
            "struct Node {\n"
        if (enable_value) code += "    Value val;\n";
        if (range_agg) code += "    Value agg;\n";
        if (lazy_prop) code += "    Lazy lazy;\n";
        code += "\n";
        if (key_type !== "none") code += `    ${key_type} key;\n`;
        if (size_option) code += "    int sz;\n";
        code += "    int pri;\n" +
            "    ptr l, r;\n"
        if (enable_par) code += "    ptr par;\n";

        code += '\n';

        // make constructor

        let params = []
        let bruh = []
        if (key_type !== 'none') {
            params.push(`${key_type} key`)
            bruh.push('key(key)')
        }
        if (enable_value) {
            params.push('Value val')
            bruh.push('val(val), agg(val)')
        }

        // default constructor
        if (params.length > 0) {
            code += '    Node() {\n'    
            code += '        pri = mt();\n'
            if (enable_value) code += '        val = vid;\n'
            if (range_agg) code += '        agg = vid;\n'
            if (lazy_prop) code += '        lazy = lid;\n'
            if (size_option) code += '        sz = 1;\n'
            code += '        l = r = nullptr;\n'
            if (enable_par) code += '        par = nullptr;\n'
            code += '    }\n\n'
        }

        let param_str = params.join(", ")
        let bruh_str = ''
        if (bruh.length > 0) bruh_str += ' : '
        bruh_str += bruh.join(", ")
        code += `    Node(${param_str})${bruh_str} {\n`
        code += '        pri = mt();\n'
        if (lazy_prop) code += '        lazy = lid;\n'
        if (size_option) code += '        sz = 1;\n'
        code += '        l = r = nullptr;\n'
        if (enable_par) code += '        par = nullptr;\n'
        code += '    }\n'

        code += "};\n\n"

        if (size_option) code += 'int sz(ptr n) { return n ? n->sz : 0; };\n'
        if (range_agg) code += 'Value agg(ptr n) { return n ? n->agg : vid; }\n'
        code += '\n'

        if (push) {
            code += "void push(ptr n) {\n" +
                "    if (!n) return;\n"
            if (lazy_prop) {
                code += "    n->val.upd(n->lazy, 1);\n" +
                    "    n->agg.upd(n->lazy, n->sz);\n" +
                    "    if (n->l) n->l->lazy += n->lazy;\n" +
                    "    if (n->r) n->r->lazy += n->lazy;\n" +
                    "    n->lazy = lid;\n"
            }
            code += "}\n\n"
        }

        if (pull) {
            code += 'ptr pull(ptr n) {\n' +
                '    if (!n) return nullptr;\n'

            if (push) code += '    push(n->l), push(n->r);\n'
            if (enable_par) code += '    if (n->l) n->l->par = n;\n' +
                '    if (n->r) n->r->par = n;\n'
            if (size_option) code += '    n->sz = sz(n->l) + 1 + sz(n->r);\n'
            if (range_agg) code += '    n->agg = agg(n->l) + n->val + agg(n->r);\n'

            code += '    return n;\n' +
                '}\n\n'
        }

        if (split_option) {
            code += `std::pair<ptr, ptr> split(ptr n, ${key_type} k) {\n`;
            code += '    if (!n) return {nullptr, nullptr};\n'
            if (enable_par) code += 'n->par = nullptr;\n'
            if (push) code += '    push(n);\n'
            code += '    if (k <= n->key) {\n' +
                '        auto [l, r] = split(n->l, k);\n' +
                '        n->l = r;\n' +
                `        return {l, ${pull ? "pull(n)" : "n"}};\n` +
                '    } else {\n' +
                '        auto [l, r] = split(n->r, k);\n' +
                '        n->r = l;\n' +
                `        return {${pull ? "pull(n)" : "n"}, r};\n` +
                '    }\n' +
                '}\n\n'
        }

        if (spliti_option) {
            code += 'std::pair<ptr, ptr> spliti(ptr n, int i) {\n' +
                '    if (!n) return {nullptr, nullptr};\n'
            if (enable_par) code += '    n->par = nullptr;\n'
            if (push) code += '    push(n);\n'
            code += '    if (i <= sz(n->l)) {\n' +
                '        auto [l, r] = spliti(n->l, i);\n' +
                '        n->l = r;\n' +
                '        return {l, pull(n)};\n' +
                '    } else {\n' +
                '        auto [l, r] = spliti(n->r, i - 1 - sz(n->l));\n' +
                '        n->r = l;\n' +
                '        return {pull(n), r};\n' +
                '    }\n' +
                '}\n\n'
        }

        if (merge_option) {
            code += 'ptr merge(ptr l, ptr r) {\n' +
                '    if (!l || !r) return l ? l : r;\n'
            if (push) code += '    push(l), push(r);\n';
            code += '    if (l->pri > r->pri) return l->r = merge(l->r, r), pull(l);\n' +
                '    else return r->l = merge(l, r->l), pull(r);\n' +
                '}\n\n'
        }

        if (range_update_key) {
            code += `void upd(ptr& n, ${key_type} lo, ${key_type} hi, Lazy lazy) {\n` +
                `    auto [lm, r] = split(n, ${range_type === 'inc exc' ? 'hi' : 'hi + 1'});\n` +
                '    auto [l, m] = split(lm, lo);\n' +
                '    if (m) m->lazy += lazy;\n' +
                '    n = merge(l, merge(m, r));\n' +
                '}\n\n'
        }

        if (range_update_index) {
            code += 'void updi(ptr& n, int lo, int hi, Lazy lazy) {\n' +
                `    auto [lm, r] = spliti(n, ${range_type === 'inc exc' ? 'hi' : 'hi + 1'});\n` +
                '    auto [l, m] = spliti(lm, lo);\n' +
                '    if (m) m->lazy += lazy;\n' +
                '    n = merge(l, merge(m, r));\n' +
                '}\n\n'
        }

        if (range_query_key) {
            code += `Value query(ptr& n, ${key_type} lo, ${key_type} hi) {\n` +
                `    auto [lm, r] = split(n, ${range_type === 'inc exc' ? 'hi' : 'hi + 1'});\n` +
                '    auto [l, m] = split(lm, lo);\n' +
                '    Value res = agg(m);\n' +
                '    n = merge(l, merge(m, r));\n' +
                '    return res;\n' +
                '}'
        }

        if (range_query_index) {
            code += 'Value queryi(ptr& n, int lo, int hi) {\n' +
                `    auto [lm, r] = spliti(n, ${range_type === 'inc exc' ? 'hi' : 'hi + 1'});\n` +
                '    auto [l, m] = spliti(lm, lo);\n' +
                '    Value res = agg(m);\n' +
                '    n = merge(l, merge(m, r));\n' +
                '    return res;\n' +
                '}'
        }

        // POST PROCESSING

        if (use_namespace_std) code = code.replaceAll("std::", "");
        if (use_ll_typedef) code = code.replaceAll("long long", "ll");
        const tab_character = getTabCharacter();
        code = code.replace(/ {4}/g, tab_character);
        document.getElementById("code_display").textContent = code;
    }

    window.onload = handleUpdate;
</script>
</body>
</html>
